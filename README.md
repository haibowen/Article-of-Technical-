# Article-of-Technical-
用于总结自己在学习过程中的一些知识感悟</br>
# JAVA中的抽象类和接口-
### 抽象类和接口

（1）、语言层面上的区别

<font color="#dd0000"> **成员方法上的区别**:</font>

  1、  java中的抽象类可以提供成员方法的实现细节，抽象方法只能是被public和protected来修饰 配合abstract关键字，子类需要实现父类的所有抽象方法，只要有抽象方法，该类就得定义为抽象类，如果子类未实现父类的抽象方法，子类就得定义为抽象类，但是抽象类可以不包含抽象方法，（个人觉得这个有点歧义，既然不包含抽象方法，抽象类存在还有什么意义！但是我们不要过分纠结这种概念问题）

2、在jdk7之前接口是不可以提供成员方法的实现细节，在jdk8以后，接口中可以提供成员方法的实现细节，接口中的静态方法，直接用接口调用该方法，不能使用实现了该接口的子类来调用，其它有实现细节的成员方法需要用default来修饰，可以用他的实现类来调用，抽象的方法默认是public的，**这里需要注意的一点是如果实现了多个接口，每个接口中都有相同的default修饰的方法，子类需要重写该方法。** 

3、java的抽象类具有自己的构造方法，接口不含有构造方法（本质上抽象类还是在类的层面，有构造方法并不奇怪，但是并不能实例化自己，）这里也有个问题，也有人说抽象类可以实例化，大致意思说，我们在实例化实现类的对象的时候，实现类的构造方法是会首先调用父类的构造方法的，这样其实就实例化了抽象类，

我们知道创建一个对象的方式有好多种，我们拿最常用的new Object();方式来说

那我们来简单理一下这个实例化的过程（这也是java约定好的），实例化是一个递归调用的过程，子类实例化的时候，会先进行递操作，一层一层往上走，直到Object以后，然后Object再一层一层往回归，这样的操作是为了子类实例化的时候，创建的对象的完整， 对象在实例化的时候，虚拟机为其分配内存，用来存放对象自己的实例变量和从父类继承过来的实例变量，这个时候实例变量的值都会默认给0，在内存分配完成之后，虚拟机就开始按照，程序员写的构造方法开始初始化，实例化。对象的创建其实是两个过程一个是初始化,另一个是实例化，（首先会初始化各个实例变量，包括自己的和从父辈继承来的，以及构造方法中的初始化，初始化完成之后，就实现了实例化）

4、那抽象类究竟能不能创建实例化，其实从汇编的角度看，程序都有一个代码段,在内存中需要占据一定的内存,而抽象类含有没有具体的实现方法,无法具体的给它分配内存空间,所以为了安全,抽象类是不能被实例化的，但对于那些没有抽象方法的抽象类，这里还需要再进一步的思考（会有问题）。另外从java语法的角度来考量的话，假设我们实例化了抽象类的对象，那么该对象调用了他自己的抽象方法，这个又如何处理？所以这里也是一个问题，在我看来抽象类是不能实例化的，这个我们把它理解为java编程语言的一个规范即可，不需要过分纠结！！！

<font color="#dd0000">**成员变量上的区别：**</font>

抽象类的成员变量可以是任意修饰符来修饰的，接口中的成员变量是public static final，抽象类中可以含有静态的代码块

<font color="#dd0000"> **继承规则上的区别：** </font>

抽象类只能被单继承，接口可以实现多个。

<font color="#dd0000" >**设计使用上的区别：**</font>

抽象类还是在类的层面上来看问题的，具有自己的构造方法和成员变量和成员方法，是在类的基础上的一种抽象，日常项目开发中把我们需要的一些通用方法尽量上移，把一些需要不同实现的方法，也上移，这个时候我们使用抽象类，就可以很好的来解决这个问题，接口可以理解为对行为的一种抽象，对一类行为的（方法）的抽象，接口的设计是为了解耦的，单独的依靠抽象类，并不能将定义和实现很好的分离开来，一味的在抽象类中新加含有具体实现的方法，其实是对不需要该方法的子类的一种污染，一味的新加抽象方法，也需要对子类不断的更改，这个时候我们使用接口来定义这种行为，在需要的子类中实现该接口，就可以很好的处理这个问题。
